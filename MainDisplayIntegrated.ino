#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BNO055.h>
#include <utility/imumaths.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define DISPLAY_DIST 155.0
#define DISPLAY_HEIGHT 35.05 
#define DISPLAY_WIDTH 15.32

// Declaration for SSD1306 display connected using software SPI:
#define OLED_DC    0
#define OLED_CS    5
#define OLED_RESET 1
#define OLED_MOSI  3
#define OLED_CLK   2

// Button pins
#define BUTTON_TOP_PIN 9
#define BUTTON_MIDTOP_PIN 16
#define BUTTON_MIDBOT_PIN 14
#define BUTTON_BOTTOM_PIN 15

#define BATTERY_SENS_PIN 28

#define DEBOUNCE_DELAY 100             // ms between accepted button events
#define PUSH_HOLD_DELAY 1000           // ms to hold button before repeating actions
#define PUSH_HOLD_REPEAT 50            // ms between repeated actions when holding button
#define BNO055_SAMPLERATE_DELAY_MS 100 // ms between IMU samples
#define BATTERY_CHECK_DELAY_MS 10000  // ms between prediction calculations


// Button class for debouncing and push-hold
class Button {
public:
  int PIN;
  unsigned long last_change;
  int state;
  unsigned long last_trigger;

  Button(int pin) {
    this->PIN = pin;
    this->last_change = 0;
    this->state = 0;
    this->last_trigger = 0;
  }

  boolean shouldTrigger(){
    int newState = digitalRead((PIN));
    boolean will_trigger = false;
    int change_diff = millis() - last_change;
    int trigger_diff = millis() - last_trigger;
    if(state == HIGH && newState == LOW && trigger_diff > DEBOUNCE_DELAY){
      will_trigger = true;
    }else if(newState == LOW && state == LOW && change_diff > PUSH_HOLD_DELAY && trigger_diff > PUSH_HOLD_REPEAT){
      will_trigger = true;
    }

    if(newState != state){
      last_change = millis();
      state = newState;
    }
    if(will_trigger){
      last_trigger = millis();
    }
    return will_trigger;
  }
};

class Vec3f {
public:
  float x, y, z;
  Vec3f() : x(0), y(0), z(0) {}


  Vec3f(float x, float y, float z) {
    this->x = x;
    this->y = y;
    this->z = z;
  }

  Vec3f add(Vec3f other) {
    return Vec3f(x + other.x, y + other.y, z + other.z);
  }

  Vec3f subtract(Vec3f other) {
    return Vec3f(x - other.x, y - other.y, z - other.z);
  }

  Vec3f multiply(float scalar) {
    float newX = x * scalar;
    float newY = y * scalar;
    float newZ = z * scalar;

    return Vec3f(newX, newY, newZ);
  }

  Vec3f cross(Vec3f other) {
    float newX = y * other.z - z * other.y;
    float newY = z * other.x - x * other.z;
    float newZ = x * other.y - y * other.x;

    return Vec3f(newX, newY, newZ);
  }

  float dot(Vec3f other) {
    return x * other.x + y * other.y + z * other.z;
  }

  Vec3f normalize() {
    float magnitude = sqrt(x * x + y * y + z * z);

    // Check for division by zero
    if (magnitude == 0) {
      // Handle the error as needed
    }

    float newX = x / magnitude;
    float newY = y / magnitude;
    float newZ = z / magnitude;

    return Vec3f(newX, newY, newZ);
  }

  float length() {
    return sqrt(x * x + y * y + z * z);
  }

  float lengthSquared() {
    return x * x + y * y + z * z;
  }

  Vec3f project(Vec3f other) {
    float dotProduct = this->dot(other);
    float uMagnitudeSquared = other.lengthSquared();

    // Check for division by zero
    if (uMagnitudeSquared == 0) {
      // Handle the error as needed
      return Vec3f(0,0,0);
    }

    float scalar = dotProduct / uMagnitudeSquared;

    return other.multiply(scalar);
  }

  Vec3f applyEWMA(float alpha, Vec3f ewma){
    return Vec3f(x*alpha + (1-alpha)*ewma.x,y*alpha + (1-alpha)*ewma.y,z*alpha + (1-alpha)*ewma.z);
  }

  Vec3f applyCircAvg(Vec3f data2){
    float diffx = max(x, data2.x) - min(x, data2.x);
    float x_val, y_val,z_val = 0;
    if (diffx > 180){
        x_val = fmod(((min(x, data2.x) + 360 + max(x,data2.x))/2), 360); // adjust x val for the smaller val to be shifted by 360 so that the averaging is a directional/circular average
    }
    
    else{
       x_val = fmod((x + data2.x)/2.0, 360); // ordinary average
    }
    float diffz = max(z, data2.z) - min(z, data2.z);
    if (diffz > 180){
        z_val = fmod(((min(z, data2.z) + 360 + max(z,data2.z))/2), 360) + 180; // adjust z val for the smaller val to be shifted by 360 so that the averaging is a directional/circular average
    }
    else{
       z_val = fmod((z + data2.z)/2.0, 360); // ordinary average
    }
    y_val = (y + data2.y)/2.0;
    return Vec3f(x_val, y_val, z_val);
  }

  String toString() {
    return "(" + String(x) + ", " + String(y) + ", " + String(z) + ")";
  }

  bool operator!=(const Vec3f &other) const {
    return x != other.x || y != other.y || z != other.z;
  }
};

const unsigned char epd_bitmap_display_map [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 
	0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x45, 
	0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x7d, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x45, 
	0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 
	0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x7d, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x05, 
	0xc0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x7d, 
	0x83, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x01, 
	0x83, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x5d, 
	0x83, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x55, 
	0x83, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x75, 
	0x83, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x83, 0x01, 
	0x83, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x83, 0x45, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x83, 0x7d, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x83, 0x45, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x83, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x83, 0x7d, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x45, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x75, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x7d, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x11, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x7d, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x05, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x7d, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x05, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0xb0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0xb0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x25, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x11, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x09, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x25, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x01, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x39, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x6d, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x45, 
	0x80, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x45, 
	0xc0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x45, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x45, 
	0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x45, 
	0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x45, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x45, 
	0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x45, 
	0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x7d, 
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
// 'number_map_0', 5x3px
const unsigned char epd_bitmap_number_map_0 [] PROGMEM = {
  0xf0, 0x88, 0xf8
};
// 'number_map_1', 5x3px
const unsigned char epd_bitmap_number_map_1 [] PROGMEM = {
  0x90, 0xf8, 0x80
};
// 'number_map_2', 5x3px
const unsigned char epd_bitmap_number_map_2 [] PROGMEM = {
  0xe8, 0xa8, 0x98
};
// 'number_map_3', 5x3px
const unsigned char epd_bitmap_number_map_3 [] PROGMEM = {
  0x88, 0xa8, 0xf8
};
// 'number_map_4', 5x3px
const unsigned char epd_bitmap_number_map_4 [] PROGMEM = {
  0x38, 0x20, 0xf8
};
// 'number_map_5', 5x3px
const unsigned char epd_bitmap_number_map_5 [] PROGMEM = {
  0xb8, 0xa8, 0xc8
};
// 'number_map_6', 5x3px
const unsigned char epd_bitmap_number_map_6 [] PROGMEM = {
  0xf8, 0xa8, 0xe8
};
// 'number_map_7', 5x3px
const unsigned char epd_bitmap_number_map_7 [] PROGMEM = {
  0x08, 0x28, 0xf8
};
// 'number_map_8', 5x3px
const unsigned char epd_bitmap_number_map_8 [] PROGMEM = {
  0xf8, 0xa8, 0xf8
};
// 'number_map_9', 5x3px
const unsigned char epd_bitmap_number_map_9 [] PROGMEM = {
  0xb8, 0xa8, 0xf8
};

// 'target_marker', 7x7px
const unsigned char epd_bitmap_target_marker [] PROGMEM = {
  0x10, 0x38, 0x44, 0xd6, 0x44, 0x38, 0x10
};
// 'center_crosshair', 9x9px
const unsigned char epd_bitmap_center_crosshair [] PROGMEM = {
  0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0xbe, 0x80, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 
  0x08, 0x00
};
// 'left_arrows', 19x9px
const unsigned char epd_bitmap_left_arrows [] PROGMEM = {
  0x00, 0xe0, 0x00, 0x03, 0xf8, 0x00, 0x0f, 0x1e, 0x00, 0x3c, 0x07, 0x80, 0xf0, 0xe1, 0xe0, 0x03, 
  0xf8, 0x00, 0x0f, 0x1e, 0x00, 0x3c, 0x07, 0x80, 0xf0, 0x01, 0xe0
};
// 'right_arrows', 19x9px
const unsigned char epd_bitmap_right_arrows [] PROGMEM = {
  0xf0, 0x01, 0xe0, 0x3c, 0x07, 0x80, 0x0f, 0x1e, 0x00, 0x03, 0xf8, 0x00, 0xf0, 0xe1, 0xe0, 0x3c, 
  0x07, 0x80, 0x0f, 0x1e, 0x00, 0x03, 0xf8, 0x00, 0x00, 0xe0, 0x00
};
// 'up_arrows', 12x9px
const unsigned char epd_bitmap_up_arrows [] PROGMEM = {
  0xc3, 0x00, 0x61, 0x80, 0x30, 0xc0, 0x18, 0x60, 0x0c, 0x30, 0x18, 0x60, 0x30, 0xc0, 0x61, 0x80, 
  0xc3, 0x00
};
// 'down_arrows', 12x9px
const unsigned char epd_bitmap_down_arrows [] PROGMEM = {
  0x0c, 0x30, 0x18, 0x60, 0x30, 0xc0, 0x61, 0x80, 0xc3, 0x00, 0x61, 0x80, 0x30, 0xc0, 0x18, 0x60, 
  0x0c, 0x30
};
// 'roll_indicator_left', 3x11px
const unsigned char epd_bitmap_roll_indicator_left [] PROGMEM = {
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0xc0
};
// 'roll_indicator_right', 3x11px
const unsigned char epd_bitmap_roll_indicator_right [] PROGMEM = {
  0xc0, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
};
// 'counterclockwise_arrows', 25x25px
const unsigned char epd_bitmap_counterclockwise_arrows [] PROGMEM = {
  0x00, 0x3e, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x07, 0xc0, 0x3f, 0x00, 0x0e, 0x00, 0x3e, 0x00, 
  0x1c, 0x00, 0x3c, 0x00, 0x38, 0x00, 0x3e, 0x00, 0x30, 0x00, 0x37, 0x00, 0x60, 0x00, 0x23, 0x00, 
  0x60, 0x00, 0x03, 0x00, 0x60, 0x00, 0x03, 0x00, 0xc0, 0x00, 0x01, 0x80, 0xc0, 0x00, 0x01, 0x80, 
  0xc0, 0x00, 0x01, 0x80, 0xc0, 0x00, 0x01, 0x80, 0xc0, 0x00, 0x01, 0x80, 0x60, 0x00, 0x03, 0x00, 
  0x60, 0x00, 0x03, 0x00, 0x62, 0x00, 0x03, 0x00, 0x36, 0x00, 0x07, 0x00, 0x3e, 0x00, 0x0e, 0x00, 
  0x1e, 0x00, 0x1c, 0x00, 0x3e, 0x00, 0x38, 0x00, 0x7e, 0x01, 0xf0, 0x00, 0x00, 0x3f, 0xe0, 0x00, 
  0x00, 0x3e, 0x00, 0x00
};
// 'clockwise_arrows', 25x25px
const unsigned char epd_bitmap_clockwise_arrows [] PROGMEM = {
  0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x7e, 0x01, 0xf0, 0x00, 0x3e, 0x00, 0x38, 0x00, 
  0x1e, 0x00, 0x1c, 0x00, 0x3e, 0x00, 0x0e, 0x00, 0x36, 0x00, 0x07, 0x00, 0x62, 0x00, 0x03, 0x00, 
  0x60, 0x00, 0x03, 0x00, 0x60, 0x00, 0x03, 0x00, 0xc0, 0x00, 0x01, 0x80, 0xc0, 0x00, 0x01, 0x80, 
  0xc0, 0x00, 0x01, 0x80, 0xc0, 0x00, 0x01, 0x80, 0xc0, 0x00, 0x01, 0x80, 0x60, 0x00, 0x03, 0x00, 
  0x60, 0x00, 0x03, 0x00, 0x60, 0x00, 0x23, 0x00, 0x30, 0x00, 0x37, 0x00, 0x38, 0x00, 0x3e, 0x00, 
  0x1c, 0x00, 0x3c, 0x00, 0x0e, 0x00, 0x3e, 0x00, 0x07, 0xc0, 0x3f, 0x00, 0x03, 0xfe, 0x00, 0x00, 
  0x00, 0x3e, 0x00, 0x00
};

// 'number_map_big_0', 6x10px
const unsigned char epd_bitmap_number_map_big_0 [] PROGMEM = {
  0x78, 0xfc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x78
};
// 'number_map_big_1', 6x10px
const unsigned char epd_bitmap_number_map_big_1 [] PROGMEM = {
  0x30, 0x70, 0xf0, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0xfc
};
// 'number_map_big_2', 6x10px
const unsigned char epd_bitmap_number_map_big_2 [] PROGMEM = {
  0x78, 0xfc, 0xcc, 0x0c, 0x7c, 0xf8, 0xc0, 0xc0, 0xfc, 0xfc
};
// 'number_map_big_3', 6x10px
const unsigned char epd_bitmap_number_map_big_3 [] PROGMEM = {
  0x78, 0xfc, 0xcc, 0x0c, 0x3c, 0x3c, 0x0c, 0xcc, 0xfc, 0x78
};
// 'number_map_big_4', 6x10px
const unsigned char epd_bitmap_number_map_big_4 [] PROGMEM = {
  0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x7c, 0x0c, 0x0c, 0x0c, 0x0c
};
// 'number_map_big_5', 6x10px
const unsigned char epd_bitmap_number_map_big_5 [] PROGMEM = {
  0xfc, 0xfc, 0xc0, 0xc0, 0xf8, 0x7c, 0x0c, 0x0c, 0xfc, 0xf8
};
// 'number_map_big_6', 6x10px
const unsigned char epd_bitmap_number_map_big_6 [] PROGMEM = {
  0x78, 0xfc, 0xcc, 0xc0, 0xf8, 0xfc, 0xcc, 0xcc, 0xfc, 0x78
};
// 'number_map_big_7', 6x10px
const unsigned char epd_bitmap_number_map_big_7 [] PROGMEM = {
  0xfc, 0xfc, 0x0c, 0x0c, 0x1c, 0x18, 0x38, 0x30, 0x70, 0x60
};
// 'number_map_big_8', 6x10px
const unsigned char epd_bitmap_number_map_big_8 [] PROGMEM = {
  0x78, 0xfc, 0xcc, 0xcc, 0x78, 0x78, 0xcc, 0xcc, 0xfc, 0x78
};
// 'number_map_big_9', 6x10px
const unsigned char epd_bitmap_number_map_big_9 [] PROGMEM = {
  0x78, 0xfc, 0xcc, 0xcc, 0xfc, 0x7c, 0x0c, 0xcc, 0xfc, 0x78
};
// 'display_menu', 128x64px
const unsigned char epd_bitmap_display_menu [] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x97, 0xfe, 0x9f, 0x88, 0x78, 0x79, 0xf7, 0xe1, 0xe0, 0x43, 0x33, 0xcf, 0x80, 0x00, 0x00, 0x01, 
  0x97, 0xfe, 0x9f, 0x9c, 0x7c, 0xf9, 0xf7, 0xe1, 0xf0, 0xe3, 0x37, 0xcf, 0x80, 0x00, 0x00, 0x01, 
  0x96, 0x06, 0x86, 0x1c, 0x6e, 0xc1, 0x81, 0x81, 0xb8, 0xe3, 0xb6, 0x0c, 0x30, 0x00, 0x00, 0x01, 
  0x96, 0x06, 0x86, 0x36, 0x66, 0xc1, 0x81, 0x81, 0x99, 0xb3, 0xf6, 0x0c, 0x30, 0x00, 0x00, 0x01, 
  0x96, 0x66, 0x86, 0x36, 0x6e, 0xd9, 0xe1, 0x81, 0xb9, 0xb3, 0xf6, 0xcf, 0x00, 0x00, 0x00, 0x01, 
  0x96, 0x66, 0x86, 0x3e, 0x7c, 0xdd, 0xe1, 0x81, 0xf1, 0xf3, 0x76, 0xef, 0x00, 0x00, 0x00, 0x01, 
  0x96, 0x06, 0x86, 0x3e, 0x78, 0xcd, 0x81, 0x81, 0xe1, 0xf3, 0x36, 0x6c, 0x30, 0x00, 0x00, 0x01, 
  0x96, 0x06, 0x86, 0x77, 0x6c, 0xcd, 0x81, 0x81, 0xb3, 0xbb, 0x36, 0x6c, 0x30, 0x00, 0x00, 0x01, 
  0x97, 0xfe, 0x86, 0x63, 0x6e, 0xfd, 0xf1, 0x81, 0xbb, 0x1b, 0x37, 0xef, 0x80, 0x00, 0x00, 0x01, 
  0x97, 0xfe, 0x86, 0x63, 0x66, 0x79, 0xf1, 0x81, 0x9b, 0x1b, 0x33, 0xcf, 0x80, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x4e, 0x82, 0x1e, 0x3c, 0x3c, 0x82, 0x0f, 0xbe, 0x7d, 0xf7, 0x80, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x86, 0x87, 0x1f, 0x3e, 0x7e, 0xc6, 0x1f, 0xbf, 0x7d, 0xf7, 0xc0, 0x00, 0x00, 0x00, 0x01, 
  0x91, 0x0a, 0x87, 0x1b, 0xb7, 0x66, 0xc6, 0x18, 0x33, 0x61, 0x86, 0xec, 0x00, 0x00, 0x00, 0x01, 
  0x92, 0x10, 0x8d, 0x99, 0xb3, 0x66, 0xc6, 0x18, 0x33, 0x61, 0x86, 0x6c, 0x00, 0x00, 0x00, 0x01, 
  0x94, 0x20, 0x8d, 0x9b, 0xb7, 0x66, 0xd6, 0x1f, 0x3f, 0x79, 0xe6, 0x60, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x42, 0x8f, 0x9f, 0x3e, 0x66, 0xfe, 0x0f, 0xbe, 0x79, 0xe6, 0x60, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x84, 0x8f, 0x9e, 0x3c, 0x66, 0xfe, 0x01, 0xb0, 0x61, 0x86, 0x6c, 0x00, 0x00, 0x00, 0x01, 
  0x93, 0x08, 0x9d, 0xdb, 0x36, 0x66, 0xee, 0x01, 0xb0, 0x61, 0x86, 0xec, 0x00, 0x00, 0x00, 0x01, 
  0x97, 0x10, 0x98, 0xdb, 0xb7, 0x7e, 0xc6, 0x1f, 0xb0, 0x7d, 0xf7, 0xc0, 0x00, 0x00, 0x00, 0x01, 
  0x92, 0x20, 0x98, 0xd9, 0xb3, 0x3c, 0x44, 0x1f, 0x30, 0x7d, 0xf7, 0x80, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x92, 0x82, 0x99, 0xb3, 0x7e, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x95, 0x44, 0x99, 0xb3, 0x7e, 0xfd, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x95, 0x48, 0x99, 0xbb, 0x18, 0x31, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x94, 0x50, 0x99, 0xbf, 0x18, 0x31, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x99, 0xbf, 0x18, 0x31, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x99, 0xb7, 0x18, 0x30, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x6e, 0x99, 0xb3, 0x18, 0x30, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x91, 0x44, 0x99, 0xb3, 0x18, 0x30, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x92, 0x64, 0x9f, 0xb3, 0x7e, 0x31, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x94, 0x44, 0x8f, 0x33, 0x7e, 0x31, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x90, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
// 'menu_selector', 124x18px
const unsigned char epd_bitmap_menu_selector [] PROGMEM = {
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 
  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0
};
// 'meters', 40x10px
const unsigned char epd_bitmap_meters [] PROGMEM = {
  0xc6, 0xfb, 0xf7, 0xde, 0x1f, 0xc6, 0xfb, 0xf7, 0xdf, 0x3f, 0xee, 0xc0, 0xc6, 0x1b, 0xb0, 0xfe, 
  0xc0, 0xc6, 0x19, 0xb0, 0xfe, 0xf0, 0xc7, 0x9b, 0xbe, 0xd6, 0xf0, 0xc7, 0x9f, 0x1f, 0xc6, 0xc0, 
  0xc6, 0x1e, 0x03, 0xc6, 0xc0, 0xc6, 0x1b, 0x03, 0xc6, 0xf8, 0xc7, 0xdb, 0xbf, 0xc6, 0xf8, 0xc7, 
  0xd9, 0xbe
};
// 'feet', 24x10px
const unsigned char epd_bitmap_feet [] PROGMEM = {
  0xfb, 0xef, 0xbf, 0xfb, 0xef, 0xbf, 0xc3, 0x0c, 0x0c, 0xc3, 0x0c, 0x0c, 0xf3, 0xcf, 0x0c, 0xf3, 
  0xcf, 0x0c, 0xc3, 0x0c, 0x0c, 0xc3, 0x0c, 0x0c, 0xc3, 0xef, 0x8c, 0xc3, 0xef, 0x8c
};
// 'colon', 6x2px
const unsigned char epd_bitmap_colon [] PROGMEM = {
	0xcc, 0xcc
};
// 'number_map_bigr_0', 10x6px
const unsigned char epd_bitmap_number_map_bigr_0 [] PROGMEM = {
	0x7f, 0x80, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xc0, 0x7f, 0x80
};
// 'number_map_bigr_1', 10x6px
const unsigned char epd_bitmap_number_map_bigr_1 [] PROGMEM = {
	0xc1, 0x00, 0xc1, 0x80, 0xff, 0xc0, 0xff, 0xc0, 0xc0, 0x00, 0xc0, 0x00
};
// 'number_map_bigr_2', 10x6px
const unsigned char epd_bitmap_number_map_bigr_2 [] PROGMEM = {
	0xf9, 0x80, 0xfd, 0xc0, 0xcc, 0xc0, 0xcc, 0xc0, 0xcf, 0xc0, 0xc7, 0x80
};
// 'number_map_bigr_3', 10x6px
const unsigned char epd_bitmap_number_map_bigr_3 [] PROGMEM = {
	0x61, 0x80, 0xe1, 0xc0, 0xcc, 0xc0, 0xcc, 0xc0, 0xff, 0xc0, 0x7f, 0x80
};
// 'number_map_bigr_4', 10x6px
const unsigned char epd_bitmap_number_map_bigr_4 [] PROGMEM = {
	0x07, 0xc0, 0x0f, 0xc0, 0x0c, 0x00, 0x0c, 0x00, 0xff, 0xc0, 0xff, 0xc0
};
// 'number_map_bigr_5', 10x6px
const unsigned char epd_bitmap_number_map_bigr_5 [] PROGMEM = {
	0xc7, 0xc0, 0xcf, 0xc0, 0xcc, 0xc0, 0xcc, 0xc0, 0xfc, 0xc0, 0x78, 0xc0
};
// 'number_map_bigr_6', 10x6px
const unsigned char epd_bitmap_number_map_bigr_6 [] PROGMEM = {
	0x7f, 0x80, 0xff, 0xc0, 0xcc, 0xc0, 0xcc, 0xc0, 0xfd, 0xc0, 0x79, 0x80
};
// 'number_map_bigr_7', 10x6px
const unsigned char epd_bitmap_number_map_bigr_7 [] PROGMEM = {
	0x00, 0xc0, 0xc0, 0xc0, 0xf0, 0xc0, 0x7c, 0xc0, 0x1f, 0xc0, 0x07, 0xc0
};
// 'number_map_bigr_8', 10x6px
const unsigned char epd_bitmap_number_map_bigr_8 [] PROGMEM = {
	0x73, 0x80, 0xff, 0xc0, 0xcc, 0xc0, 0xcc, 0xc0, 0xff, 0xc0, 0x73, 0x80
};
// 'number_map_bigr_9', 10x6px
const unsigned char epd_bitmap_number_map_bigr_9 [] PROGMEM = {
	0x67, 0x80, 0xef, 0xc0, 0xcc, 0xc0, 0xcc, 0xc0, 0xff, 0xc0, 0x7f, 0x80
};
// 'fire_marker', 13x13px
const unsigned char epd_bitmap_fire_marker [] PROGMEM = {
	0x02, 0x00, 0x42, 0x10, 0x30, 0x60, 0x28, 0xa0, 0x18, 0xc0, 0x00, 0x00, 0xc0, 0x18, 0x00, 0x00, 
	0x18, 0xc0, 0x28, 0xa0, 0x30, 0x60, 0x42, 0x10, 0x02, 0x00
};

// Array of all bitmaps for convenience.
const int epd_bitmap_allArray_LEN = 47;
const unsigned char* epd_bitmap_allArray[epd_bitmap_allArray_LEN] = {
	epd_bitmap_number_map_0, // 0
	epd_bitmap_number_map_1, // 1
	epd_bitmap_number_map_2, // 2
	epd_bitmap_number_map_3, // 3
	epd_bitmap_number_map_4, // 4
	epd_bitmap_number_map_5, // 5 
	epd_bitmap_number_map_6, // 6
	epd_bitmap_number_map_7, // 7
	epd_bitmap_number_map_8, // 8
	epd_bitmap_number_map_9, // 9 
	epd_bitmap_display_map, // 10
	epd_bitmap_target_marker, // 11
	epd_bitmap_center_crosshair, // 12
	epd_bitmap_left_arrows, // 13
	epd_bitmap_right_arrows, // 14
	epd_bitmap_up_arrows, // 15
	epd_bitmap_down_arrows, // 16
	epd_bitmap_roll_indicator_left, // 17
	epd_bitmap_roll_indicator_right, // 18
	epd_bitmap_counterclockwise_arrows, // 19
	epd_bitmap_clockwise_arrows, // 20
	epd_bitmap_number_map_big_0, // 21
	epd_bitmap_number_map_big_1, // 22
	epd_bitmap_number_map_big_2, // 23
	epd_bitmap_number_map_big_3, // 24
	epd_bitmap_number_map_big_4, // 25
	epd_bitmap_number_map_big_5, // 26
	epd_bitmap_number_map_big_6, // 27
	epd_bitmap_number_map_big_7, // 28
	epd_bitmap_number_map_big_8, // 29
	epd_bitmap_number_map_big_9, // 30
	epd_bitmap_display_menu, // 31
	epd_bitmap_menu_selector, // 32
	epd_bitmap_meters, // 33
	epd_bitmap_feet, // 34
	epd_bitmap_colon, // 35
	epd_bitmap_number_map_bigr_0, // 36
	epd_bitmap_number_map_bigr_1, // 37
	epd_bitmap_number_map_bigr_2, // 38
	epd_bitmap_number_map_bigr_3, // 39
	epd_bitmap_number_map_bigr_4, // 40
	epd_bitmap_number_map_bigr_5, // 41
	epd_bitmap_number_map_bigr_6, // 42
	epd_bitmap_number_map_bigr_7, // 43
	epd_bitmap_number_map_bigr_8, // 44
	epd_bitmap_number_map_bigr_9, // 45
	epd_bitmap_fire_marker // 46
};

// Global Variables
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS); // initialize display class
Adafruit_BNO055 bno = Adafruit_BNO055(55,0x28, &Wire);                                                    // initialize IMU 1 class
int mode = 1; // 0 - menu, 1 - target
Button top_button(BUTTON_TOP_PIN);
Button bottom_button(BUTTON_BOTTOM_PIN);
Button midtop_button(BUTTON_MIDTOP_PIN);
Button midbot_button(BUTTON_MIDBOT_PIN);
float alpha = 0.5; // ewma coefficient
unsigned long last_sensor_check;
unsigned long last_battery_check;
Vec3f sensor_data = {0,0,0};
Vec3f grav_vec = {-9.8,0,0};

// Menu Variables
int selected_param = 0; // 0 - distance, 1 - speed, 2 - units
int raw_distance = 18;
int raw_speed = 41; // units / second
int units = 0; // 0 - meters, 1 - feet

// Target Variables
bool target_set = false;
int battery = 99;
int target_x = 59;
int target_y = 28;
float target_yaw = 0;
float target_pitch = 0;
float aim_pitch = 0;

void setup() {
  Wire.setSDA(20);
  Wire.setSCL(21);
  Wire.begin();

  Serial.begin(115200); // set communication speed for the serial monitor
  //while (!Serial) delay(10);  // wait for serial port to open!

  Serial.println(F("Booting"));

  if(!display.begin(SSD1306_SWITCHCAPVCC)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  if (!bno.begin()){
    Serial.print("Oops, both BNO055s haven't been detected. ... Check your wiring or I2C ADDR!");
    while (1);
  }  

  Serial.println(F("Peripherals Loaded"));

  pinMode(BUTTON_TOP_PIN, INPUT_PULLUP);
  pinMode(BUTTON_BOTTOM_PIN, INPUT_PULLUP);
  pinMode(BUTTON_MIDTOP_PIN, INPUT_PULLUP);
  pinMode(BUTTON_MIDBOT_PIN, INPUT_PULLUP);

  // Clear the buffer.
  display.clearDisplay();
}

void loop() {
  // put your main code here, to run repeatedly:

  read_buttons();

  if(mode == 0){
    render_menu();
  }else{
    if (millis()-last_sensor_check > BNO055_SAMPLERATE_DELAY_MS){    
      display.clearDisplay();           
      sensor_data = read_sensors();   
/*
      Serial.print("1- (");
      Serial.print(sensor_data.x);
      Serial.print(",");
      Serial.print(sensor_data.y);
      Serial.print(",");
      Serial.print(sensor_data.z);
      Serial.println(")");
*/
      render_target();
    }
  }

  if(millis()-last_battery_check > BATTERY_CHECK_DELAY_MS){
    update_battery();
  }
}

void update_battery(){
  last_battery_check = millis();

  int sensorValue = analogRead(BATTERY_SENS_PIN);
  // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):
  float voltage = sensorValue * (5.0 / 1023.0);
  float adjustedV = voltage * 1.303;

  // 4.2 V to 3.4 V range
  float percentage = 154.7 * (adjustedV - 3.4) * (adjustedV - 3.4);
  if(percentage > 99){
    battery = 99;
  }else if(percentage < 0){
    battery = 0;
  }else{
    battery = (int) percentage;
  }

  Serial.print("Battery Voltage Raw: ");
  Serial.println(voltage);
  Serial.print("Battery Voltage Adjusted: ");
  Serial.println(adjustedV);
  Serial.print("Battery %: ");
  Serial.println(battery);
}

void render_menu(){
  display.clearDisplay();

  int range_1 = (int) raw_distance / 100;
  int range_2 = (int) (raw_distance/10) % 10;
  int range_3 = (int) raw_distance % 10;

  int speed_1 = (int) raw_speed / 100;
  int speed_2 = (int) (raw_speed/10) % 10;
  int speed_3 = (int) raw_speed % 10;

  // Main Background
  display.drawBitmap(0, 0, epd_bitmap_allArray[31], 128, 64, 1); 

  // Selector Bar
  display.drawBitmap(2, 2+selected_param*21, epd_bitmap_allArray[32], 124, 18, 1); 

  // Range Readout
  display.drawBitmap(102, 6, epd_bitmap_allArray[21+range_1], 6, 10, 1); 
  display.drawBitmap(109, 6, epd_bitmap_allArray[21+range_2], 6, 10, 1); 
  display.drawBitmap(116, 6, epd_bitmap_allArray[21+range_3], 6, 10, 1); 

  // Speed Readout
  display.drawBitmap(98, 26, epd_bitmap_allArray[21+speed_1], 6, 10, 1); 
  display.drawBitmap(105, 26, epd_bitmap_allArray[21+speed_2], 6, 10, 1); 
  display.drawBitmap(112, 26, epd_bitmap_allArray[21+speed_3], 6, 10, 1); 

  // Units Display
  if(units == 0){
    display.drawBitmap(59, 48, epd_bitmap_allArray[33], 40, 10, 1); 
  }else{
    display.drawBitmap(59, 48, epd_bitmap_allArray[34], 24, 10, 1); 
  }
  // Load to the display
  display.display();
}

Vec3f read_sensors(){
  last_sensor_check = millis();
  uint8_t sys, gyro, accel, mag = 0;
  Vec3f s0_1 = {0,0,0};
  uint32_t address = 0;
  bno.getCalibration(&sys, &gyro, &accel, &mag);

  sensors_event_t event;
  bno.getEvent(&event);
  
  // using orientation for this example and can do the same for multiple sensors
  s0_1 = {(float)event.orientation.x, -(float)(event.orientation.y), (float)event.orientation.z};
  sensor_data = s0_1.applyCircAvg(sensor_data);

  //Serial.print("Raw: ");
  //Serial.println(s0_1.toString());
  //Serial.print("Mean: ");
  //Serial.println(sensor_data.toString());

  sensors_event_t event3;
  bno.getEvent(&event3,Adafruit_BNO055::VECTOR_GRAVITY);
  
  // update gravity vec for the calculation of gravitational component
  grav_vec = {(float)event3.acceleration.x, (float)event3.acceleration.y, (float)event3.acceleration.z};
  // map the values observed for y and z to their actual range of angles.
  
  return sensor_data;
}

void read_buttons(){
  if(bottom_button.shouldTrigger()){
    mode = (mode+1) % 2;
  }
  if(mode == 0){
    if(midbot_button.shouldTrigger()){
      if(selected_param == 0 && raw_distance > 1){
        raw_distance--;
      }else if(selected_param == 1 && raw_speed > 1){
        raw_speed--;
      }else if(selected_param == 2){
        units = (units+1) % 2;
      }
      target_set = false;
    }
    if(midtop_button.shouldTrigger()){
      if(selected_param == 0 && raw_distance < 998){
        raw_distance++;
      }else if(selected_param == 1 && raw_speed < 998){
        raw_speed++;
      }else if(selected_param == 2){
        units = (units+1) % 2;
      }
      target_set = false;
    }
    if(top_button.shouldTrigger()){
      selected_param = (selected_param+1) % 3;
    }
  }else if(mode == 1){
    if(midbot_button.shouldTrigger()){
      target_pitch = sensor_data.y;
      target_yaw = sensor_data.x;
      aim_pitch = calculate_prediction();
      target_set = true;
    }
    if(top_button.shouldTrigger()){
      Serial.println(target_x);
      Serial.println(target_y);
    }
    if(midtop_button.shouldTrigger()){
      
    }
  }
}

void render_target(){
  float roll = sensor_data.z-90;
  float pitch = sensor_data.y;
  float yaw = sensor_data.x;

  float abs_pitch = abs(pitch);
  int pitch_1 = (int) abs_pitch / 10;
  int pitch_2 = (int) abs_pitch % 10;
  int pitch_3 = (int) (abs_pitch*10) % 10;
  int pitch_4 = (int) (abs_pitch*100) % 10;

  float abs_yaw = abs(yaw);
  int yaw_1 = (int) abs_yaw / 100;
  int yaw_2 = (int) (abs_yaw/10) % 10;
  int yaw_3 = (int) abs_yaw % 10;
  int yaw_4 = (int) (abs_yaw*10) % 10;
  int yaw_5 = (int) (abs_yaw*100) % 10;

  int battery_1 = battery / 10;
  int battery_2 = battery % 10;

  float adjusted_yaw = yaw;
  if(yaw > 180){
    adjusted_yaw = yaw-360;
  }
  float x_diff = pitch-aim_pitch;
  float y_diff = calcCircDiff(yaw,target_yaw);

  target_x = abs(x_diff) < 0.5 ? 63 : 63 - 1.75*(pitch-aim_pitch);
  target_y = abs(y_diff) < 0.5 ? 32 : 32 - 1*(yaw-target_yaw);

  bool left_arrows = target_y < 3;
  bool right_arrows = target_y > 66;
  bool up_arrows = target_x > 120;
  bool down_arrows = target_x < 3;

  int crosshair_x = 59;
  int crosshair_y = 28;

  // Main Background
  display.drawBitmap(0, 0, epd_bitmap_allArray[10], 128, 64, 1);

  // Pitch Indicator
	display.drawBitmap(107, 21, epd_bitmap_allArray[36+pitch_1], 10, 6, 1);
	display.drawBitmap(107, 28, epd_bitmap_allArray[36+pitch_2], 10, 6, 1);
	display.drawBitmap(107, 38, epd_bitmap_allArray[36+pitch_3], 10, 6, 1);
	display.drawBitmap(107, 45, epd_bitmap_allArray[36+pitch_4], 10, 6, 1);
	// Pitch Sign
	if(pitch > 0){
		display.drawBitmap(109, 16, epd_bitmap_allArray[35], 6, 2, 1);
	}
	// Yaw Indicator
	display.drawBitmap(2, 17, epd_bitmap_allArray[36+yaw_1], 10, 6, 1);
	display.drawBitmap(2, 24, epd_bitmap_allArray[36+yaw_2], 10, 6, 1);
	display.drawBitmap(2, 31, epd_bitmap_allArray[36+yaw_3], 10, 6, 1);
	display.drawBitmap(2, 41, epd_bitmap_allArray[36+yaw_4], 10, 6, 1);
	display.drawBitmap(2, 48, epd_bitmap_allArray[36+yaw_5], 10, 6, 1);
	// Yaw Sign
	if(yaw > 0){
		display.drawBitmap(4, 12, epd_bitmap_allArray[35], 6, 2, 1);
	}
  
  // Roll Indicator
  if(roll < -10){
    display.drawBitmap(51, 20, epd_bitmap_allArray[20], 25, 25, 1);
  }else if(roll > 10){
    display.drawBitmap(51, 20, epd_bitmap_allArray[19], 25, 25, 1);
  }else{
    int offset = (int) (roll*2.5);
    display.drawBitmap(61-offset, 42, epd_bitmap_allArray[18], 3, 11, 1);
    display.drawBitmap(61+offset, 12, epd_bitmap_allArray[17], 3, 11, 1);
  }

  // Battery Percentage
  display.drawBitmap(121, 37, epd_bitmap_allArray[battery_1], 5, 3, 1);
  display.drawBitmap(121, 41, epd_bitmap_allArray[battery_2], 5, 3, 1);
  // Battery Fill
  for(int i = 0; i < battery_1; i++){
    display.drawPixel(122,59-i,1);
    display.drawPixel(123,59-i,1);
    display.drawPixel(124,59-i,1);
  }

  // Arrows
  if(target_set && down_arrows){  
    display.drawBitmap(3, 3, epd_bitmap_allArray[16], 12, 9, 1);
    display.drawBitmap(3, 52, epd_bitmap_allArray[16], 12, 9, 1);
  }
  if(target_set && up_arrows){  
    display.drawBitmap(105, 3, epd_bitmap_allArray[15], 12, 9, 1);
    display.drawBitmap(105, 52, epd_bitmap_allArray[15], 12, 9, 1);
  }
  if(target_set && left_arrows){  
    display.drawBitmap(54, 3, epd_bitmap_allArray[13], 19, 9, 1);
  }
  if(target_set && right_arrows){
    display.drawBitmap(54, 52, epd_bitmap_allArray[14], 19, 9, 1);
  }

  // Crosshair
  if(target_set){
    display.drawBitmap(crosshair_x,crosshair_y, epd_bitmap_allArray[12], 9, 9, 1);
  }

  // Target Marker
  if(target_set && target_x > 3 && target_x < 120 && target_y > 3 && target_y < 66){
    display.drawBitmap(target_x-3,target_y-3, epd_bitmap_allArray[11], 7, 7, 1);
  }

  // Load to the display
  display.display();
}

// Works with any unit scaling as long as units are internally consistent
float ballistics(float initV, float initA, float initX, float initY, float dt, float gravity, float dragCoeff, float stopY, float stopX, bool returnY){
    float lastVel = initV;
    float lastAngle = initA;
    float lastX = initX;
    float lastY = initY;
    
    int index = 1;
    float time = dt;
    while(lastX <= stopX && lastY >= stopY){
        float dv = -gravity*sin(lastAngle) - dragCoeff*lastVel*lastVel;
        float da = -gravity*cos(lastAngle) / lastVel;
        float dx = lastVel*cos(lastAngle);
        float dy = lastVel*sin(lastAngle);
        lastVel = (lastVel + dv*dt);
        lastAngle = (lastAngle + da*dt);
        lastX = (lastX + dx*dt);
        lastY = (lastY + dy*dt);
        index++;
        time += dt;
    }
    
    if(returnY){
        return lastY;
    }else{
        return lastX;
    }
}

float calcTheta(float v0, float dist, float dt, float coeff, float yOff){ // Units in meters and seconds, returns angle in degrees
    float gravity = 9.81; // m/s^2
    float upperAngle = 45;
    float lowerAngle = -90;
    float tryAngle = 10;
    float curD = 0;
    float returnY = yOff > 0;
    float stopY = returnY ? 0 : yOff;
    float stopX = returnY ? dist : 1000;
    
    float maxRange = ballistics(v0, (upperAngle * 71.0) / 4068.0, 0, 0, dt, gravity, coeff, stopY, stopX, returnY);
    
    if(!returnY && maxRange < dist){
        return upperAngle;
    }else if(returnY && maxRange < yOff){
        return upperAngle;
    }
    
    stopX = returnY ? dist : dist*1.1;
    
    int tries = 0;
    while(tries < 100){
        float end = ballistics(v0, (tryAngle * 71.0) / 4068.0, 0, 0, dt, gravity, coeff, stopY, stopX, returnY);
        curD = returnY ? yOff-end : dist-end;
        float absD = curD < 0 ? -curD : curD;

        if(absD < 0.01){
            break;
        }else if(curD < 0){
            upperAngle = tryAngle;
        }else{
            lowerAngle = tryAngle;
        }
        tryAngle = (upperAngle+lowerAngle)/2;
        tries++;
    }
    return tryAngle;
}


float calculate_prediction(){
  float pitch_rad = (target_pitch * 71.0) / 4068.0;
  float distance_m = units == 1 ? raw_distance*0.3048 : raw_distance;
  float speed_m = units == 1 ? raw_speed*0.3048 : raw_speed;
  float y_offset = distance_m*tan(pitch_rad);
  float drag_coeff = 0.00235;
  float dt = 0.0001;
  Serial.print("Y Off: ");
  Serial.println(y_offset);
  Serial.print("Pitch: ");
  Serial.println(target_pitch);
  Serial.print("Pitch Rad: ");
  Serial.println(pitch_rad);

  float angle = calcTheta(speed_m, distance_m, dt, drag_coeff, y_offset);
  Serial.print("Calculated Angle: ");
  Serial.println(angle);

  return angle;
}

float calcCircDiff(float angle1, float angle2){
  return fmodf((angle1 - angle2 + 180), 360) - 180;
}

Vec3f getCartesianOrientation(float pitch, float yaw){
  float f = (pitch * 71.0) / 4068.0;
  float g = (-yaw * 71.0) / 4068.0;
  float h = cos(g);
  float i = sin(g);
  float j = cos(f);
  float k = sin(f);

	return Vec3f(i * j, -k, h * j);
}